<?phpclass Tweet_model extends CI_Model {	/*	 * 	 * Construct the Tweets object	 * Include Mongo libarary	 * Change to TweetData Database	 * 	 */	public function __construct(){		parent::__construct();		$this->load->library('Mongo_db');		$this->mongo_db->switch_db('test');	}	/*	 * create_index	 * 	 * Input:	$keys = array of fields/keys, $options = array of	 *			Mongodb Options	 * 	 * Post:	Adds indexes to tweets collection based on	 * 			- array of $keys where the KEY is the	 * 			Field and the Value is whether should be 'asc' or 'desc'	 * 			if left empty will default to 'asc'	 * 			- array of options are Mongodb Options for example:	 * 				'unique' => TRUE	 *///----------------------------------------------------------------------------------------------------	 	 //uneccessary. feel it should be removed.	 //tweet objects have a unique id already.	 //if needed, we can use the id_str variable in case we ever reach max int.	 //is there ever a situation where duplicate ids arise?//----------------------------------------------------------------------------------------------------	public function create_index($keys, $options)  	{			$this->mongo_db->add_index('tweets',$keys,$options);	}		/*	 * Function:  insert	 *	 * Input:	Tweet Object from JSON Object from Twitter	 * Output:	False if failed, nothing if True;	 * 	 * Pre:		Objects ready for addition to 'tweets' Collection	 * Post:	Obejct saved in 'tweets' Collection	 */	public function insert($tweet){		if (empty($tweet))		{		   			//write to error_log.txt			$fp = fopen('error_log.txt', 'w');			$t = time();			$now = date("d-m-y", $t);			fwrite($fp, $now. " Error.  Function: insert.  Could not write tweet to tweets Collection.\n\n");			fclose($fp);			return false;		}						else		{			//duplicate prevention code goes here.			$this->mongo_db->insert('tweets',$tweet);		}			}		/*	 * Function:  insert	 *	 * Input:	Tweet Object from JSON Object from Twitter	 * Output:	False if failed, nothing if True;	 * 	 * Pre:		Array of Objects ready for addition to 'tweets' Collection	 * Post:	Array of Obejcts saved in 'tweets' Collection	 */		public function batch_insert($tweet){		if (empty($tweet))		{		   			//write to error_log.txt			$fp = fopen('error_log.txt', 'w');			$t = time();			$now = date("d-m-y", $t);			fwrite($fp, $now. " Error.  Function: insert.  Could not write tweet to tweets Collection.\n\n");			fclose($fp);			return false;		}							else		{			//duplicate prevention code goes here.			$this->mongo_db->batch_insert('tweets',$tweet);		}			}		/*	 * get_all	 * 	 * Input:	None	 * Output:	Returns the the entire tweets collection.  All fields included.	 * 	 * Pre & Post:No Change	 * 	 */	public function get_all()	{		return $this->mongo_db->get('tweets');	}		/*	 * search	 *	 *Input:  $select: type = array. purpose = pick which fields you wish to be returned.	 *				   If all fields are desired, pass an empty array.	 *	 *	 *		  $where:  type = array. purpose = pick the search criteria where fields are 	 *				   set to certain values.  Limit:  Set up to 1 Value per field.  Must be equal operator.	 */	public function search($select, $where)	{					//stupidity prevention		if ( ! is_array($select))	 	{	 		$select = array();	 	}		if ( ! is_array($where))		{			$where = array();		}				//actual coding				//if both arrays are empty do this:		if ( empty($select) && empty($where))		{			return $this->mongo_db->get('tweets');		}						//if one of the arrays is empty do this:		elseif ( empty($select) xor empty($where))		{			if( empty($select))			{				return $this->mongo_db->or_where($where)->get('tweets');			}						else			{				return $this->mongo_db->select($select)->get('tweets');			}		}				//if both arrays have values, do this:		else		{			return $this->mongo_db->select($select)->or_where($where)->get('tweets');		}	}			public function search_like($field, $value, $wildStart, $wildEnd)	{		return $this->mongo_db->like($field, $value, 'i', $wildStart, $wildEnd);	}		//STILL TESTING DO NOT USE!	public function delete_like($field, $value)	{			//WORK IN PROGRESS.  TOO MANY UNKNOWNS TO CONTINUE AT THIS POINT IN TIME.				//while(--collection length--)		//{		//do not know if this is correct way to get value from the desired $field				//$arbvar = preg_match('/.$value./', tweets->$field)		//$this->mongo_db->where(--condition--)->delete('tweets');		//}				return TRUE;	}			/*	 * search_range	 *	 *Input:  $select: type = array. purpose = pick which fields you wish to be returned.	 *				   If all fields are desired, pass an empty array.	 *	 *	 *		  $where:  type = array. purpose = pick the search criteria where fields are 	 *				   set to certain values.	 */	public function search_range()	{	}		/*	 * update_tweets	 * 	 * Input: Requires array, Key(field) => Value(value)	 * Post: Returns TRUE from library Mongo_db.php => update_all() 	 * 	 * 	 *///----------------------------------------------------------------------------------------------------	 	 //i dont even know where we would ever need it.	 //will mongodb merge new information with old information?//----------------------------------------------------------------------------------------------------	public function update_tweets(Array $query)	{		return $this->mongo_db->update_all('tweets',$query,false);		//false refers to fact it won't add a document if none available	}		/*	 * delete_tweets_collection	 * 	 * Post:  Drops tweets table to start fresh	 * 	 *///----------------------------------------------------------------------------------------------------	 //naming seems off.  would recommend just naming it drop_collection.	 //i like what it does, however, need specification when such function would be used.	 //i would also suggest adding a verification to see if you would want to drop the entire table.	 //accidents happen and i would like to prevent them as much as possible.//----------------------------------------------------------------------------------------------------	public function delete_tweets_collection()	{		$this->mongo_db->drop_collection('tweets');	}//----------------------------------------------------------------------------------------------------		//we probably will not need this.	//would rather incorporate preventative measures into create_tweets.//----------------------------------------------------------------------------------------------------	public function delete_duplicates()	{		$tweets = $this->mongo_db->get('tweets');		$i=$h=0;		foreach ($tweets as $tweet)		{			//check if unique tweetid if yes add it to unique_keys			//for next position check			if (!in_array($unique_keys,$tweet['id'],true))			{				$unique_keys[$i] = $tweet['id'];//tweet id only				$i++;			}//else put in non_unique_keys for deletion			else 			{				$non_unique_keys[$h] = $tweet;//tweet object				$h++;			}		}//end foreach with non_unique_keys available for deletion				foreach ($non_unique_keys as $tweet)		{				$this->mongo_db->delete_all($tweet['id']);			$this->save_tweets($tweet);		}	}	}